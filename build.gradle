buildscript {
	repositories {
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		mavenCentral()
		mavenLocal()
	}
	dependencies {
		classpath "cuchaz:enigma-cli:${project.enigma_version}"
		classpath "net.fabricmc:stitch:${project.stitch_version}"
		classpath "commons-io:commons-io:2.11.0"
		classpath "de.undercouch:gradle-download-task:5.1.0"
		classpath "net.fabricmc:tiny-remapper:${project.tiny_remapper_version}"
		classpath "net.fabricmc.unpick:unpick:${project.unpick_version}"
		classpath "net.fabricmc.unpick:unpick-format-utils:${project.unpick_version}"
		classpath "net.fabricmc:name-proposal:${project.name_proposal_version}"
	}
}

plugins {
	id 'java' // for constants, packages, javadoc
	id 'de.undercouch.download' version '4.1.2'
	id 'maven-publish'
	id "com.diffplug.spotless" version "6.4.2"
	id 'net.fabricmc.filament' version '0.3.0'
}


def youtubeVersion = project.youtube_version
def youtubeApkSha1 = project.youtube_apk_sha1


def ENV = System.getenv()
// Fetch build number from Github Actions
def buildNumber = ENV.BUILD_NUMBER ?: "local"

def mappingsVersion = "${youtubeVersion}+build.$buildNumber"
version = mappingsVersion

if (ENV.BRANCH_NAME) {
	def branch = ENV.BRANCH_NAME.substring(ENV.BRANCH_NAME.lastIndexOf('/') + 1)
	if (youtubeVersion != branch) {
		throw new IllegalStateException("Branch name (${branch}) does not match the yt version (${youtubeVersion})")
	}
}

repositories {
	mavenCentral()
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	mavenLocal()
}

configurations {
	asm
	enigmaRuntime {
		extendsFrom asm
	}
	javadocClasspath
	decompileClasspath
	mappingPoetJar {
		transitive = false
	}
	mappingPoet {
		extendsFrom mappingPoetJar
		extendsFrom asm
		transitive = true
	}
	unpick {
		extendsFrom asm
	}
}

def unpickMetaFile = file("unpick-definitions/unpick.json")

dependencies {
	enigmaRuntime "cuchaz:enigma-swing:${project.enigma_version}"
	enigmaRuntime "net.fabricmc:name-proposal:${project.name_proposal_version}"
	javadocClasspath "org.jetbrains:annotations:${project.jetbrains_annotations_version}"
	javadocClasspath "com.google.code.findbugs:jsr305:3.0.2" // for some other jsr annotations
	decompileClasspath "net.fabricmc:cfr:${project.cfr_version}"
	mappingPoetJar "net.fabricmc:mappingpoet:${project.mappingpoet_version}"
	unpick "net.fabricmc.unpick:unpick-cli:${project.unpick_version}"
	asm "org.ow2.asm:asm:${project.asm_version}"
	asm "org.ow2.asm:asm-tree:${project.asm_version}"
	asm "org.ow2.asm:asm-commons:${project.asm_version}"
	asm "org.ow2.asm:asm-util:${project.asm_version}"
}

def setupGroup = "jar setup"
def mappingsGroup = "yt-mappings"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"
def mappingsDir = file("mappings")

def cacheFilesYoutube = file(".gradle/youtube")
def tempDir = file(".gradle/temp")
def youtubeApkLocation = "youtube.apk"
def intermediaryJar = file("youtube-${youtubeVersion}-intermediary.jar")
def unpickedJar = file("youtube-${youtubeVersion}-intermediary-unpicked.jar")
def namedJar = file("${youtubeVersion}-named.jar")
def versionFile = new File(cacheFilesYoutube, "youtube-${youtubeVersion}.json")

def youtubeJarName = "youtube-${youtubeVersion}.jar"
def youtubeJarFile = new File(cacheFilesYoutube, youtubeJarName)
def libs = new File("build/libs/")

import com.google.common.hash.Hashing
import cuchaz.enigma.command.CheckMappingsCommand
import cuchaz.enigma.command.ComposeMappingsCommand
import cuchaz.enigma.command.ConvertMappingsCommand
import cuchaz.enigma.command.MapSpecializedMethodsCommand
import groovy.io.FileType
import groovy.json.JsonSlurper
import net.fabricmc.stitch.commands.CommandMergeTiny
import net.fabricmc.stitch.commands.CommandReorderTiny
import net.fabricmc.stitch.commands.CommandRewriteIntermediary
import net.fabricmc.stitch.commands.tinyv2.CommandMergeTinyV2
import net.fabricmc.stitch.commands.tinyv2.CommandReorderTinyV2
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import net.fabricmc.nameproposal.MappingNameCompleter
import org.apache.commons.io.FileUtils
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.FieldVisitor
import org.objectweb.asm.Opcodes;

import java.nio.charset.StandardCharsets
import java.util.zip.GZIPOutputStream

boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		def hash = com.google.common.io.Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString().equals(checksum)
	}
	return false
}


task downloadIntermediary(type: Download) {
	group = buildMappingGroup
	def url = "https://github.com/NebelNidas/yt-intermediary/raw/master/mappings/${youtubeVersion}.tiny"
	src com.google.common.net.UrlEscapers.urlFragmentEscaper().escape(url)
	dest new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary.tiny")
}

task downloadIntermediaryV2(type: Download) {
	group = buildMappingGroup
	// def url = "https://maven.fabricmc.net/net/fabricmc/intermediary/${youtubeVersion}/intermediary-${youtubeVersion}-v2.jar"
	// src com.google.common.net.UrlEscapers.urlFragmentEscaper().escape(url)
	src file("libs/youtube-${youtubeVersion}-intermediary-v2.jar")
	dest new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary-v2.jar")

	def output = new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary-v2.tiny")
	outputs.file output

	doLast {
		copy {
			from({ zipTree(downloadIntermediaryV2.dest) }) {
				from 'mappings/mappings.tiny'
				rename 'mappings.tiny', "../${output.name}"
			}

			into output.parentFile
		}
	}
}

import java.util.zip.ZipFile
import java.io.File

task convertApkToJar {
	group = setupGroup
	inputs.file youtubeApkLocation

	doLast {
		logger.lifecycle(":converting apk to jar")

		exec {
			workingDir "${cacheFilesYoutube}"
			executable "${projectDir}/libs/dex2jar-${dex2jar_version}/d2j-dex2jar.bat"
			args "${projectDir}/${youtubeApkLocation}"
		}
	}
}

import java.net.URI;
import java.nio.file.DirectoryStream;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.LinkOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

void deleteDirectory(Path path) throws IOException {
	if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
		try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
			for (Path entry : entries) {
			deleteDirectory(entry);
			}
		}
	}
	Files.delete(path);
}

task renameGeneratedJar(type: Copy, dependsOn: convertApkToJar) {
	from ("${cacheFilesYoutube}")
	include 'youtube-dex2jar.jar'
	destinationDir file("${cacheFilesYoutube}")
	rename 'youtube-dex2jar.jar', youtubeJarName

	doLast {
		logger.lifecycle(":renaming generated jar")
	}
}

task removeUnneededPackages(dependsOn: renameGeneratedJar) {
	group = setupGroup
	inputs.file youtubeJarFile
	outputs.file youtubeJarFile

	doLast {
		logger.lifecycle(":removing unneeded packages")

		List<String> packagesToDelete = Arrays.asList(
			// 'android',
			// 'androidx',
			// 'com',
			'dagger',
			'io',
			'J',
			'j$',
			'kotlinx',
			'org'
		);
		/* Define ZIP File System Properies in HashMap */
		Map<String, String> zipProperties = new HashMap<>();
		/* We want to read an existing ZIP File, so we set this to False */
		zipProperties.put("create", "false");

		Path path = youtubeJarFile.toPath();
		URI zipFile = URI.create("jar:" + path.toUri());

		/* Create ZIP file System */
		try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, zipProperties)) {
			for (String pack : packagesToDelete) {
				Path pathInZipfile = zipfs.getPath(pack);
				deleteDirectory(pathInZipfile);
			}
		}
	}
}

task invertIntermediary(dependsOn: downloadIntermediary, type: FileOutput) {
	group = buildMappingGroup
	def v1Input = downloadIntermediary.dest

	output = new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary-inverted.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":building inverted intermediary")

		String[] v1Args = [
				v1Input.getAbsolutePath(),
				output.getAbsolutePath(),
				"intermediary", "official"
		]

		new CommandReorderTiny().run(v1Args)
	}
}

task invertIntermediaryv2(dependsOn: downloadIntermediaryV2, type: FileOutput) {
	group = buildMappingGroup
	def v2Input = new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary-v2.tiny")

	output = new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary-inverted-v2.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":building inverted intermediary v2")

		String[] v2Args = [
				v2Input.getAbsolutePath(),
				output.getAbsolutePath(),
				"intermediary", "official"
		]

		new CommandReorderTinyV2().run(v2Args)
	}
}

task patchIntermediary(dependsOn: downloadIntermediary) {
	group = buildMappingGroup
	def intermediaryTinyInput = downloadIntermediary.outputs.files.singleFile

	def outputFile = new File(cacheFilesYoutube, "youtube-${youtubeVersion}-intermediary-full.tiny")
	outputs.file(outputFile)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":patching intermediary")
		String[] args = [
				youtubeJarFile.getAbsolutePath(),
				intermediaryTinyInput.getAbsolutePath(),
				outputFile.getAbsolutePath(),
				"--writeAll"
		]

		new CommandRewriteIntermediary().run(args)
	}
}

task mapIntermediaryJar(dependsOn: [downloadIntermediary, removeUnneededPackages]) {
	group = mapJarGroup
	inputs.file(youtubeJarFile)
	outputs.file(intermediaryJar)

	//Force the task to always run
	outputs.upToDateWhen { false }


	doLast {
		logger.lifecycle(":mapping youtube to intermediary")
		def tinyInput = downloadIntermediary.dest
		mapJar(intermediaryJar, youtubeJarFile, tinyInput, null, "official", "intermediary")
	}
}

task mappingsUnpicked(dependsOn: "unpickIntermediaryJar", type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.enigmaRuntime
	mainClass = 'cuchaz.enigma.gui.Main'

	args '-jar'
	args unpickedJar.getAbsolutePath()
	args '-mappings'
	args mappingsDir.getAbsolutePath()
	args '-profile'
	args 'enigma_profile.json'

	jvmArgs "-Xmx2048m"
}

task startMapping(dependsOn: mapIntermediaryJar, type: JavaExec) {
	group = mappingsGroup

	classpath = configurations.enigmaRuntime
	mainClass = 'cuchaz.enigma.gui.Main'

	args '-jar'
	args intermediaryJar.getAbsolutePath()
	args '-mappings'
	args mappingsDir.getAbsolutePath()
	args '-profile'
	args 'enigma_profile.json'

	jvmArgs "-Xmx2048m"
}

task checkMappings(dependsOn: mapIntermediaryJar) {
	group = buildMappingGroup
	inputs.dir mappingsDir
	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
				intermediaryJar.getAbsolutePath(),
				mappingsDir.getAbsolutePath()
		]

		try {
			new CheckMappingsCommand().run(args)
		} catch (IllegalStateException ignored) {
			// just print, don't fail the task
		}
	}
}

task buildMappingsTiny(dependsOn: mapIntermediaryJar, type: WithV2FileOutput) {
	group = buildMappingGroup
	inputs.dir mappingsDir
	if (!libs.exists()) {
		libs.mkdirs()
	}

	v1Output = new File(tempDir, "yt-mappings.tiny")
	v2Output = new File(tempDir, "yt-mappings-v2.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":generating tiny mappings")

		new MapSpecializedMethodsCommand().run(
			intermediaryJar.getAbsolutePath(),
			"enigma",
			mappingsDir.getAbsolutePath(),
			"tinyv2:intermediary:named",
			v2Output.getAbsolutePath()
		)

		new ConvertMappingsCommand().run(
			"tinyv2",
			v2Output.getAbsolutePath(),
			"tiny:intermediary:named",
			v1Output.getAbsolutePath())
	}
}

task mergeTiny(dependsOn: ["buildMappingsTiny", "invertIntermediary"], type: FileOutput) {
	group = buildMappingGroup
	def mappingsTinyInput = buildMappingsTiny.v1Output
	def intermediaryTinyInput = invertIntermediary.output

	def unorderedResultMappings = new File(tempDir, "mappings-unordered.tiny")
	output = new File(tempDir, "mappings.tiny")
	outputs.file(output)

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":merging yt-mappings and intermediary")
		String[] args = [
				intermediaryTinyInput.getAbsolutePath(),
				mappingsTinyInput.getAbsolutePath(),
				unorderedResultMappings.getAbsolutePath(),
				"intermediary",
				"official"
		]

		new CommandMergeTiny().run(args)

		logger.lifecycle(":reordering merged intermediary")
		String[] args2 = [
				unorderedResultMappings.getAbsolutePath(),
				output.getAbsolutePath(),
				"official", "intermediary", "named"
		]

		new CommandReorderTiny().run(args2)
	}
}

task tinyJar(type: Jar, dependsOn: mergeTiny) {
	group = buildMappingGroup
	outputs.upToDateWhen { false }
	archiveFileName = "yt-mappings-${mappingsVersion}.jar"
	destinationDirectory.set(file("build/libs"))
	classifier = ""
	from(mergeTiny.output) {
		rename { "mappings/mappings.tiny" }
	}
	manifest {
		attributes("Youtube-Version-Id": youtubeVersion)
	}
}

task compressTiny(dependsOn: [tinyJar, mergeTiny], type: FileOutput) {
	group = buildMappingGroup
	def outputFile = new File(libs, "yt-mappings-tiny-${mappingsVersion}.gz")
	outputs.file(outputFile)
	output = outputFile

	def inputFile = mergeTiny.output

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":compressing tiny mappings")

		def buffer = new byte[1024]
		def fileOutputStream = new FileOutputStream(outputFile)
		def outputStream = new GZIPOutputStream(fileOutputStream)
		def fileInputStream = new FileInputStream(inputFile)

		def length
		while ((length = fileInputStream.read(buffer)) > 0) {
			outputStream.write(buffer, 0, length)
		}

		fileInputStream.close()
		outputStream.finish()
		outputStream.close()
	}
}

clean.doFirst {
	delete tempDir, cacheFilesYoutube
}

tasks.build.dependsOn "compressTiny","tinyJar","v2UnmergedMappingsar", "v2MergedMappingsJar", "javadocJar"

task exportMappingsOfficial(dependsOn: downloadIntermediary) {
	def composeInput = downloadIntermediary.dest

	doLast {
		logger.lifecycle(":exporting mappings")
		String[] args = [
				"tiny",
				composeInput.getAbsolutePath(),
				"enigma",
				file("mappings/").getAbsolutePath(),
				"enigma",
				file("mappings_official/").getAbsolutePath(),
				"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task importMappingsOfficial(dependsOn: invertIntermediary) {
	def composeInput = invertIntermediary.output

	doLast {
		logger.lifecycle(":importing mappings")
		String[] args = [
				"tiny",
				composeInput.getAbsolutePath(),
				"enigma",
				file("mappings_official/").getAbsolutePath(),
				"enigma",
				file("mappings/").getAbsolutePath(),
				"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task mapNamedJar(dependsOn: ["mergeV2", "unpickIntermediaryJar"]) {
	group = mapJarGroup
	inputs.file(youtubeJarFile)
	outputs.file(namedJar)

	//Force the task to always run
	outputs.upToDateWhen { false }

	def jsrToJetbrains = [
		"javax/annotation/Nullable": "org/jetbrains/annotations/Nullable",
		"javax/annotation/Nonnull": "org/jetbrains/annotations/NotNull",
		"javax/annotation/concurrent/Immutable": "org/jetbrains/annotations/Unmodifiable"
	]

	doLast {
		logger.lifecycle(":mapping youtube to named")

		mapJar(namedJar, unpickedJar, mergeV2.output, null, "intermediary", "named") {
			it.withMappings { out ->
				jsrToJetbrains.each { e ->
					out.acceptClass e.key, e.value
				}
			}
		}
	}
}

combineUnpickDefinitions {
	group = 'unpick'
	input = file('unpick-definitions')
	output = new File(tempDir, 'definitions.unpick')
}

remapUnpickDefinitionsIntermediary {
	dependsOn buildMappingsTiny
	group = 'unpick'
	output = new File(tempDir, 'intermediary-definitions.unpick')
	mappings = buildMappingsTiny.v2Output
}

task unpickIntermediaryJar(type: JavaExec, dependsOn: [mapIntermediaryJar, "constantsJar", remapUnpickDefinitionsIntermediary]) {
	outputs.upToDateWhen { false }
	group "unpick"

	mainClass = "daomephsta.unpick.cli.Main"
	systemProperty "java.util.logging.config.file", file('unpick-logging.properties')
	classpath configurations.unpick

	doFirst {
		args intermediaryJar.absolutePath, unpickedJar.absolutePath, remapUnpickDefinitionsIntermediary.output.get().asFile.absolutePath, constantsJar.archiveFile.get().asFile.absolutePath

		configurations.decompileClasspath.files.each {
			args it.absolutePath
		}
	}
}

// Setup the build for the unpicked constants

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 17
}

sourceSets {
	constants
	packageDocs // package info files
}

spotless {
	java {
		licenseHeaderFile(rootProject.file("HEADER"))
	}
}

task constantsJar(type: Jar) {
	from sourceSets.constants.output
	archiveClassifier = "constants"
}

task sourcesJar(type: Jar, dependsOn: classes) {
	archiveClassifier = "sources"
	from sourceSets.constants.allSource
}

// Only build jars for package infos if we need to actually expose stuff like annotation in the future.

build.dependsOn constantsJar

task insertAutoGeneratedEnumMappings(dependsOn : [buildMappingsTiny, mapIntermediaryJar], type : FileOutput){
	group = buildMappingGroup
	File noEnumV2 = buildMappingsTiny.v2Output
	output = new File(tempDir, "unmerged-named-v2-with-enum.tiny")

	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":seeking auto-mappable fields for unmerged mappings")

		MappingNameCompleter.completeNames(
				intermediaryJar.toPath(),
				noEnumV2.toPath(),
				downloadIntermediary.dest.toPath(),
				output.toPath()
		)
	}
}

task mergeV2(dependsOn: ["v2UnmergedMappingsJar", "invertIntermediaryv2"], type: FileOutput) {
	def mergedV2 = new File(tempDir, "merged-v2.tiny");

	output = new File(tempDir, "merged-reordered-v2.tiny")
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":merging yt-mappings and intermediary v2")
		String[] args = [
				invertIntermediaryv2.output.getAbsolutePath(),
				insertAutoGeneratedEnumMappings.output.getAbsolutePath(),
				mergedV2.getAbsolutePath(),
				"intermediary",
				"official"
		]

		new CommandMergeTinyV2().run(args)

		//Reorder the mappings to match the output of loom
		args = [
				mergedV2.getAbsolutePath(),
				output.getAbsolutePath(),
				"official",
				"intermediary",
				"named"
		]
		new CommandReorderTinyV2().run(args)
	}
}

task v2UnmergedMappingsJar(dependsOn: [insertAutoGeneratedEnumMappings, combineUnpickDefinitions], type: Jar) {
	def mappings = insertAutoGeneratedEnumMappings.output
	group = "mapping build"
	outputs.upToDateWhen { false }
	archiveFileName = "yt-mappings-${mappingsVersion}-v2.jar"

	from(file(mappings)) {
		rename mappings.name, "mappings/mappings.tiny"
	}
	from(combineUnpickDefinitions.output) {
		rename combineUnpickDefinitions.output.get().asFile.name, "extras/definitions.unpick"
	}
	from (file(unpickMetaFile)) {
		expand version: project.unpick_version
		rename unpickMetaFile.name, "extras/unpick.json"
	}
	destinationDirectory.set(file("build/libs"))
	manifest {
		attributes("Youtube-Version-Id": youtubeVersion)
	}
}

task v2MergedMappingsJar(dependsOn: ["mergeV2"], type: Jar) {
	def mappings = mergeV2.output
	group = "mapping build"
	outputs.upToDateWhen { false }
	archiveFileName = "yt-mappings-${mappingsVersion}-mergedv2.jar"

	from(file(mappings)) {
		rename mappings.name, "mappings/mappings.tiny"
	}
	from(combineUnpickDefinitions.output) {
		rename combineUnpickDefinitions.output.get().asFile.name, "extras/definitions.unpick"
	}
	from (file(unpickMetaFile)) {
		expand version: project.unpick_version
		rename unpickMetaFile.name, "extras/unpick.json"
	}
	destinationDirectory.set(file("build/libs"))
	manifest {
		attributes("Youtube-Version-Id": youtubeVersion)
	}
}

def fakeSourceDir = file(".gradle/temp/fakeSource")
task genFakeSource(type: JavaExec, dependsOn: ["mergeV2", "mapNamedJar"]) {
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	mainClass = "net.fabricmc.mappingpoet.Main"
	classpath configurations.mappingPoet
	// use merged v2 so we have all namespaces in jd
	args mergeV2.output.getAbsolutePath(), namedJar.getAbsolutePath(), fakeSourceDir.getAbsolutePath(), youtubeJarFile.getAbsolutePath()

	doLast {
		logger.lifecycle ":Fake source generated"
	}
}

task decompileCFR(type: JavaExec, dependsOn: [mapNamedJar]) {
	mainClass = "org.benf.cfr.reader.Main"

	args namedJar.getAbsolutePath(), "--outputdir", file("namedSrc").absolutePath

	doFirst {
		file("namedSrc").deleteDir()
		classpath = configurations.decompileClasspath
	}
}

javadoc {
	dependsOn genFakeSource
	dependsOn removeUnneededPackages
	group = "javadoc generation"
	outputs.upToDateWhen { false }

	def mappingPoetJar = project.provider { zipTree configurations.mappingPoetJar.singleFile }

	failOnError = false
	maxMemory = '2G'

	// verbose = true // enable to debug
	options {
		// verbose() // enable to debug
		source = "17"
		encoding = 'UTF-8'
		charSet = 'UTF-8'
		memberLevel = JavadocMemberLevel.PRIVATE
		splitIndex true
		tags(
				'apiNote:a:API Note:',
				'implSpec:a:Implementation Requirements:',
				'implNote:a:Implementation Note:'
		)
		taglets "net.fabricmc.mappingpoet.jd.MappingTaglet"
		// taglet path, header, extra stylesheet settings deferred
		it.use()

		addBooleanOption "-allow-script-in-comments", true
		addBooleanOption "-ignore-source-errors", true
		links(
				'https://guava.dev/releases/21.0/api/docs/',
				'https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.0/',
				'https://logging.apache.org/log4j/2.x/log4j-api/apidocs/',
				"https://javadoc.io/doc/org.jetbrains/annotations/${project.jetbrains_annotations_version}/",
				'https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.2/',
				'https://javadoc.lwjgl.org/',
				'https://fastutil.di.unimi.it/docs/',
				'https://netty.io/4.1/api/',
				'https://commons.apache.org/proper/commons-logging/javadocs/api-1.1.3/',
				'https://commons.apache.org/proper/commons-lang/javadocs/api-3.5',
				'https://commons.apache.org/proper/commons-io/javadocs/api-2.5',
				'https://commons.apache.org/proper/commons-codec/archives/1.10/apidocs',
				'https://commons.apache.org/proper/commons-compress/javadocs/api-1.8.1/',
				"https://docs.oracle.com/en/java/javase/17/docs/api/"
		)
		// https://docs.oracle.com/en/java/javase/17/docs/specs/man/javadoc.html#additional-options-provided-by-the-standard-doclet
		addBooleanOption 'Xdoclint:html', true
		addBooleanOption 'Xdoclint:syntax', true
		addBooleanOption 'Xdoclint:reference', true
		addBooleanOption 'Xdoclint:accessibility', true
	}
	source fileTree(fakeSourceDir) + sourceSets.constants.allJava + sourceSets.packageDocs.allJava
	classpath = configurations.javadocClasspath.plus removeUnneededPackages.outputs.files.asFileTree

	doLast {
		project.copy {
			from mappingPoetJar
			include "copy_on_click.js"
			into javadoc.outputDirectory
		}
	}

	doFirst {
		// lazy setting
		options {
			tagletPath configurations.mappingPoet.files.toList()
			header mappingPoetJar.get().filter { it.name == 'javadoc_header.txt' }.singleFile.text.trim() // cannot include line breaks
			addFileOption "-add-stylesheet", mappingPoetJar.get().filter { it.name == 'forms.css' }.singleFile
		}
	}
}

task javadocJar(type: Jar, dependsOn: ["javadoc"]) {
	group = "javadoc generation"

	from javadoc.destinationDir

	archiveVersion.set mappingsVersion
	archiveClassifier = 'javadoc'
}

generatePackageInfoMappings {
	dependsOn mapIntermediaryJar
	inputJar = intermediaryJar
	packageName = "unused/packageinfo/"
	outputDir = file("mappings/unused/packageinfo")
}

javadocLint {
	group = "javadoc generation"
	mappingDirectory = file("mappings")
}

check.dependsOn javadocLint

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'app.revanced'
			artifactId "yt-mappings"
			version mappingsVersion

			artifact(compressTiny.output) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact(tinyJar)
			artifact(v2UnmergedMappingsJar) {
				classifier "v2"
			}
			artifact(v2MergedMappingsJar) {
				classifier "mergedv2"
			}
			artifact(constantsJar) {
				classifier "constants"
			}
			artifact sourcesJar
			artifact javadocJar
		}

	}
	repositories {
		if (ENV.MAVEN_URL) {
			maven {
				url ENV.MAVEN_URL
				credentials {
					username ENV.MAVEN_USERNAME
					password ENV.MAVEN_PASSWORD
				}
			}
		}
	}
}

// A task to ensure that the version being released has not already been released.
task checkVersion {
	doFirst {
		def xml = new URL("https://maven.fabricmc.net/net/fabricmc/yarn/maven-metadata.xml").text
		def metadata = new XmlSlurper().parseText(xml)
		def versions = metadata.versioning.versions.version*.text();
		if (versions.contains(version)) {
			throw new RuntimeException("${version} has already been released!")
		}
	}
}

publish.mustRunAfter checkVersion

void mapJar(File output, File input, File mappings, File libraries, String from, String to,
		Action<TinyRemapper.Builder> action = { }) {
	if (output.exists()) {
		output.delete()
	}

	def remapperBuilder = TinyRemapper.newRemapper()
			.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
			.invalidLvNamePattern(~/\$\$\d+/)
			.inferNameFromSameLvIndex(true)

	action.execute(remapperBuilder)
	def remapper = remapperBuilder
			.build()

	try {
		def outputConsumerBuilder = new OutputConsumerPath.Builder(output.toPath())
		// expose output consumer builder to function if there is need in the future
		def outputConsumer = outputConsumerBuilder.build()
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		// libraries.eachFileRecurse(FileType.FILES) { file ->
		// 	remapper.readClassPath(file.toPath())
		// }
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

class FileOutput extends DefaultTask {
	@OutputFile
	File output
}

class FileOutputInput extends DefaultTask {
	@InputFile
	File input

	@OutputFile
	File output
}

class WithV2FileOutput extends DefaultTask {
	@OutputFile
	File v1Output
	@OutputFile
	File v2Output
}
